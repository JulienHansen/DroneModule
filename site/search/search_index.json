{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"drone-control","text":"<p>Vectorized PID controllers for quadrotor drones, designed for parallel simulation of N environments simultaneously using PyTorch.</p> <pre><code>from drone_control import load_config, CrazyfliePIDController\n\ncfg  = load_config(\"configs/crazyflie.yaml\")\nctrl = CrazyfliePIDController.from_drone_config(cfg, num_envs=4, dt=0.002)\n\nthrust, moment = ctrl(root_state, target_pos=ref, command_level=\"position\")\n</code></pre>"},{"location":"#features","title":"Features","text":"Feature Details Multi-environment Batched over N parallel envs via PyTorch Multi-rate loops Position/velocity @ 100 Hz, attitude/rate @ 500 Hz 4 command levels <code>position</code>, <code>velocity</code>, <code>attitude</code>, <code>body_rate</code> Derivative on measurement No derivative kick on setpoint steps Full Euler equation Gyroscopic term \u03c9 \u00d7 (J\u00b7\u03c9) included Geometric controller Lee SO(3) position + attitude controller Control allocation Physics-based <code>QuadMixer</code> (X and + layouts) RC rate profiles Betaflight, RaceFlight, Actual, KISS curves Pole-placement tuning <code>tune_from_physics</code> derives gains from bandwidth YAML configuration Gains, limits and physics from config files Partial reset Reset only a subset of environments"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2014 install and first example</li> <li>Architecture \u2014 how the cascade loops work</li> <li>Firmware Architecture \u2014 sensor-to-motor pipeline explained</li> <li>API: CrazyfliePIDController</li> <li>API: LeePositionController</li> <li>API: QuadMixer</li> <li>API: Rate Profiles</li> <li>API: PID_Vectorized</li> <li>API: Configuration Loader</li> <li>YAML Config Format \u2014 full config schema</li> <li>Gain Tuning \u2014 pole-placement guide</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#loop-hierarchy","title":"Loop hierarchy","text":"<p><code>CrazyfliePIDController</code> implements a 4-level cascaded PID architecture that mirrors the Crazyflie 2.x firmware:</p> <pre><code>                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n target_pos \u2500\u2500\u25b6  \u2502  Position loop   (pos_pid)    @ 100 Hz           \u2502\u2500\u2500\u25b6 vel_sp\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n vel_sp     \u2500\u2500\u25b6  \u2502  Velocity loop   (vel_pid)    @ 100 Hz           \u2502\u2500\u2500\u25b6 roll/pitch/thrust_cmd\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n att_sp     \u2500\u2500\u25b6  \u2502  Attitude loop   (att_pid)    @ 500 Hz           \u2502\u2500\u2500\u25b6 rate_sp\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n rate_sp    \u2500\u2500\u25b6  \u2502  Rate loop       (manual PID) @ 500 Hz           \u2502\u2500\u2500\u25b6 moment [N\u00b7m]\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can enter the cascade at any level via <code>command_level</code>.</p>"},{"location":"architecture/#multi-rate-scheduling-decimation","title":"Multi-rate scheduling (decimation)","text":"<p>The simulation runs at a fixed timestep <code>dt</code> (typically 2 ms = 500 Hz). Slower loops are skipped on most steps:</p> <pre><code>sim step:   0    1    2    3    4    5    6    7    8    9   10  ...\npos/vel:    \u2713                        \u2713                        \u2713   (100 Hz)\natt/rate:   \u2713    \u2713    \u2713    \u2713    \u2713    \u2713    \u2713    \u2713    \u2713    \u2713    \u2713   (500 Hz)\n</code></pre> <p><code>posvel_decimation = round(sim_rate / posvel_rate)</code> = 500/100 = 5 <code>att_decimation    = round(sim_rate / att_rate)</code>    = 500/500 = 1</p> <p>Between decimated steps, velocity and position setpoints are held constant.</p>"},{"location":"architecture/#position-loop","title":"Position loop","text":"<p>Input: position error [m] Output: velocity setpoint [m/s], clamped to <code>pos_vel_max</code></p> <pre><code>e_pos = target_pos \u2212 pos\nvel_sp = clamp(pos_kp\u00b7e_pos + pos_ki\u00b7\u222be_pos, \u2212vel_max, +vel_max)\n</code></pre>"},{"location":"architecture/#velocity-loop","title":"Velocity loop","text":"<p>Input: velocity error in body-horizontal frame [m/s] Output: roll/pitch setpoints [rad] + raw thrust command [PWM]</p> <p>Velocity is first projected into the body-horizontal frame using the current yaw angle, so that commands are always given in the world frame:</p> <pre><code>vel_body_x =  cos(\u03c8)\u00b7vx + sin(\u03c8)\u00b7vy\nvel_body_y = \u2212sin(\u03c8)\u00b7vx + cos(\u03c8)\u00b7vy\n</code></pre> <p>Horizontal output (converted from deg to rad internally):</p> <pre><code>pitch_cmd = clamp( vel_kp_x \u00b7 e_vbx, \u2212pitch_max, +pitch_max )\nroll_cmd  = clamp(\u2212vel_kp_y \u00b7 e_vby, \u2212roll_max,  +roll_max  )\n</code></pre> <p>Vertical output:</p> <pre><code>thrust_cmd = thrust_base + vel_kp_z \u00b7 e_vz \u00b7 vel_thrust_scale\nthrust_cmd = clamp(thrust_cmd, thrust_min, thrust_max)\n</code></pre>"},{"location":"architecture/#attitude-loop","title":"Attitude loop","text":"<p>Input: attitude error [rad] (roll, pitch, yaw) Output: body-rate setpoint [rad/s]</p> <pre><code>e_att  = wrap(att_sp \u2212 att_actual)\nrate_sp = att_kp\u00b7e_att + att_ki\u00b7\u222be_att + att_kd\u00b7\u0117_att\n</code></pre>"},{"location":"architecture/#rate-loop-euler-equation","title":"Rate loop &amp; Euler equation","text":"<p>Input: body-rate error [rad/s] Output: moment [N\u00b7m]</p> <p>Uses the full rigid-body Euler equation:</p> <pre><code>\u03c4 = J \u00b7 \u03b1_ref + \u03c9 \u00d7 (J \u00b7 \u03c9)\n</code></pre> <p>where:</p> <ul> <li><code>\u03b1_ref</code> = rate PID output (angular acceleration setpoint [rad/s\u00b2])</li> <li><code>\u03c9 \u00d7 (J\u00b7\u03c9)</code> = gyroscopic compensation term</li> </ul> <p>The derivative is computed on the measurement (not the error) to avoid derivative kick when the rate setpoint changes:</p> <pre><code>\u03b1_ref = kp\u00b7e_\u03c9 + ki\u00b7\u222be_\u03c9 \u2212 kd\u00b7\u03c9\u0307_meas\n</code></pre>"},{"location":"architecture/#yaw-setpoint-management","title":"Yaw setpoint management","text":"<p>Yaw is handled separately from roll/pitch because it integrates over time:</p> <ul> <li>Absolute target (<code>target_yaw</code>): setpoint is set directly, optionally   clamped to within <code>yaw_max_delta</code> of the current heading.</li> <li>Rate target (<code>target_yaw_rate</code>): setpoint is integrated each step   (<code>yaw_sp += yaw_rate \u00b7 dt</code>) and wrapped to <code>[\u2212\u03c0, \u03c0]</code>.</li> <li>If neither is provided, yaw setpoint holds its last value.</li> </ul>"},{"location":"architecture/#pid-implementation","title":"PID implementation","text":"<p>All four loops use <code>PID_Vectorized</code>, which supports:</p> Feature Detail Integration Trapezoidal rule Derivative filter Tustin bilinear (<code>tau &gt; 0</code>) or backward difference (<code>tau = 0</code>) Derivative on measurement Pass <code>measurement_dot</code> to avoid kick Anti-windup Back-calculation from output saturation Integral clamping Separate <code>integral_limit</code> before output saturation Feed-forward <code>kff * feedforward</code> added to output Multi-axis Single instance handles all 3 axes simultaneously (<code>[N, 3]</code> tensors)"},{"location":"architecture/#output-units","title":"Output units","text":"Output Shape Unit <code>thrust</code> <code>[N, 1]</code> Newtons [N] <code>moment</code> <code>[N, 3]</code> Newton-metres [N\u00b7m] <p>Internally, thrust is managed in raw PWM units (0\u201365535) and converted to Newtons using <code>thrust_cmd_scale = max_thrust / thrust_cmd_max</code>, derived automatically from the drone's <code>max_thrust</code> in the YAML config.</p>"},{"location":"firmware-architecture/","title":"Modern Quadcopter Firmware Architecture","text":"<p>This document describes the complete sensor-to-actuator pipeline of a modern quadcopter flight controller, from raw IMU samples to PWM/DShot commands sent to the ESCs. Three reference firmwares are compared throughout: Betaflight (racing/freestyle), PX4 (autonomous UAV), and Crazyflie (research micro-drone).</p>"},{"location":"firmware-architecture/#1-high-level-pipeline","title":"1. High-Level Pipeline","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   raw        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  filtered    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Sensors    \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502  IMU Filter  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502 State Estimator  \u2502\n\u2502 IMU/Baro/GPS \u2502              \u2502  (LPF / RPM) \u2502              \u2502  (EKF/Mahony)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                      \u2502 pose, vel, rates\n                                                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  setpoint    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 RC / Mission \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502  Reference   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502  Control Cascade   \u2502\n\u2502   Planner    \u2502              \u2502  Generator   \u2502              \u2502  pos\u2192vel\u2192att\u2192rate  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                      \u2502 thrust + moments\n                                                                      \u25bc\n                                                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                                             \u2502  Control Allocator \u2502\n                                                             \u2502    (QuadMixer)     \u2502\n                                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                      \u2502 \u03c9 per motor\n                                                                      \u25bc\n                                                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                                             \u2502   Motor / ESC      \u2502\n                                                             \u2502 DShot / OneShot    \u2502\n                                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"firmware-architecture/#2-sensors-and-acquisition","title":"2. Sensors and Acquisition","text":""},{"location":"firmware-architecture/#21-imu","title":"2.1 IMU","text":"<p>The Inertial Measurement Unit is the heart of every flight controller. It provides:</p> Signal Typical sensor Rate Angular velocity (gyroscope) ICM-42688-P, MPU-6000 3.2\u20138 kHz Linear acceleration (accelerometer) Same die 1\u20134 kHz Magnetic heading (magnetometer, optional) QMC5883L 100\u2013200 Hz <p>The gyroscope is the most critical signal: it feeds the innermost (rate) control loop. Any latency or noise here directly degrades attitude tracking.</p> <p>Oversampling. Modern firmwares (Betaflight \u2265 4.0) run the IMU SPI bus at 8 MHz and read the sensor at its full ODR (e.g., 8 kHz for the ICM-42688-P), then decimate to the control loop rate. This converts quantisation noise into broadband noise that is more easily filtered.</p>"},{"location":"firmware-architecture/#22-barometer-and-gps","title":"2.2 Barometer and GPS","text":"Sensor Purpose Typical rate Barometer (BMP388, DPS310) Altitude hold, climb rate 50\u2013200 Hz GPS (M10, ZED-F9P) Position hold, return-to-home 1\u201320 Hz Optical flow (PMW3901) Low-altitude position hold (no GPS) 100\u2013400 Hz LiDAR / ToF (VL53L5CX) Terrain-following, landing 30\u201360 Hz <p>GPS and barometer readings are always fused inside the state estimator because their rates are too low to feed control loops directly.</p>"},{"location":"firmware-architecture/#3-imu-signal-processing","title":"3. IMU Signal Processing","text":"<p>Before state estimation, raw sensor data passes through several filtering stages.</p>"},{"location":"firmware-architecture/#31-static-hardware-anti-alias-filter","title":"3.1 Static hardware anti-alias filter","text":"<p>MEMS IMUs include an on-chip low-pass filter configurable via SPI. It is set to slightly below the Nyquist frequency of the ODR. For a 3.2 kHz ODR the cutoff is typically 1.6 kHz.</p>"},{"location":"firmware-architecture/#32-rpm-notch-filters-betaflight-dynamic-notch","title":"3.2 RPM-notch filters (Betaflight Dynamic Notch)","text":"<p>Motor vibrations appear as narrow harmonic peaks in the gyro spectrum at exact multiples of the motor electrical frequency:</p> <pre><code>f_vibe = N_poles/2 \u00d7 RPM/60   (Hz)\n</code></pre> <p>Bidirectional DShot (Betaflight \u2265 4.1, PX4 \u2265 1.13) reads back actual motor RPM via the ESC telemetry line at ~1 kHz. Each firmware loop updates per-motor notch filters centered on the 1st, 2nd, and 3rd harmonics. Because the notch follows the exact motor speed, the filter can be very narrow (high Q \u2248 250\u2013500), introducing negligible phase delay at other frequencies.</p> <p>Without RPM feedback, firmwares fall back to a dynamic-frequency notch that tracks peaks in the real-time FFT of the gyro signal (Betaflight Dynamic Notch v2).</p>"},{"location":"firmware-architecture/#33-gyro-low-pass-filter-lpf","title":"3.3 Gyro low-pass filter (LPF)","text":"<p>A biquad (2nd-order IIR) or PT1 (1st-order) filter removes broadband high-frequency noise. Typical cutoffs:</p> <ul> <li>Racing quad: 200\u2013400 Hz (minimise phase delay \u2192 better feel)</li> <li>Cinema/freestyle: 100\u2013200 Hz (smoother at cost of latency)</li> <li>Crazyflie: 80 Hz biquad (small, light, resonant frame)</li> </ul> <p>Phase lag matters. Each biquad at 200 Hz introduces roughly 3\u20138\u00b0 of phase delay at 50 Hz (the typical mechanical bandwidth). Excessive filtering is a primary cause of oscillations because the PID derivative term amplifies delayed noise.</p>"},{"location":"firmware-architecture/#34-accelerometer-lpf","title":"3.4 Accelerometer LPF","text":"<p>The accelerometer is not used by the rate loop. It only feeds state estimation and is filtered aggressively (10\u201330 Hz cutoff) because vibration contamination is severe.</p>"},{"location":"firmware-architecture/#4-state-estimation","title":"4. State Estimation","text":""},{"location":"firmware-architecture/#41-complementary-filter-mahony-madgwick","title":"4.1 Complementary filter (Mahony / Madgwick)","text":"<p>Used in Betaflight, Crazyflie, and any firmware prioritising speed over accuracy.</p> <p>Mahony filter (Crazyflie default):</p> <pre><code>\u03c9_mes = (acc \u00d7 g_est + mag \u00d7 m_est) \u00d7 k_P + \u222b(\u00b7)\u00d7k_I\n\u03c9_filt = \u03c9_gyro + \u03c9_mes\nq\u0307 = \u00bd q \u2297 [0, \u03c9_filt]\nq \u2190 q / \u2016q\u2016\n</code></pre> <p>The vector cross-product <code>acc \u00d7 g_est</code> gives a rotation error proportional to the tilt. The integral term removes gyro bias. This runs at the full IMU rate (500\u20131000 Hz on Crazyflie).</p> <p>Madgwick filter (slightly more accurate, same cost): uses gradient descent on the quaternion to minimise the algebraic error between predicted and measured gravity/magnetic directions.</p> <p>Both filters have one tunable parameter (the fusion gain <code>\u03b2</code> for Madgwick, <code>k_P/k_I</code> for Mahony) that sets the trade-off between gyro tracking (low gain = trusts gyro, drifts slowly) and accelerometer correction (high gain = rejects drift, noisier).</p>"},{"location":"firmware-architecture/#42-extended-kalman-filter-ekf","title":"4.2 Extended Kalman Filter (EKF)","text":"<p>Used in PX4 (<code>ekf2</code>) and for position estimation in Crazyflie.</p> <p>The EKF maintains a full state vector:</p> <pre><code>x = [p, v, q, b_g, b_a, b_mag, b_wind, ...]\u1d40\n</code></pre> <p>where <code>p</code> is position, <code>v</code> velocity, <code>q</code> attitude quaternion, and the <code>b_*</code> terms are biases. The prediction step integrates the IMU using Newton\u2013Euler dynamics; the correction step fuses GPS, barometer, magnetometer, optical flow, and visual-inertial odometry (VIO) with individual noise models.</p> <p>PX4's <code>ekf2</code> runs at 100\u2013250 Hz. The innovation (measurement residual) is monitored continuously; large innovations trigger automatic sensor fault detection.</p>"},{"location":"firmware-architecture/#43-position-estimation","title":"4.3 Position estimation","text":"<p>For indoor hover without GPS, PX4 and Crazyflie use optical flow + barometer fusion:</p> <pre><code>v_body \u2248 f_focal \u00d7 (flow_px / dt) / altitude\np += \u222b R \u00d7 v_body \u00d7 dt   (EKF prediction)\np_corrected = EKF(baro, flow)\n</code></pre> <p>For outdoor precision (RTK), a moving baseline GPS heading + 5 cm RTK position replaces the magnetometer and barometer respectively.</p>"},{"location":"firmware-architecture/#5-reference-generation","title":"5. Reference Generation","text":""},{"location":"firmware-architecture/#51-rc-input-decoding","title":"5.1 RC input decoding","text":"<p>The radio receiver sends commands on SBUS, CRSF, or ELRS at 50\u20131000 Hz. Raw PWM values (1000\u20132000 \u00b5s) are normalised to [-1, 1]:</p> <pre><code>stick = (pwm - 1500) / 500\n</code></pre> <p>Sticks in this package's <code>rate_profiles.py</code> operate on exactly this normalised input.</p>"},{"location":"firmware-architecture/#52-flight-mode-stack","title":"5.2 Flight mode stack","text":"Mode What RC controls Who generates rate setpoint Acro Body rates directly Rate profile (this package) Angle Euler angle setpoints Outer angle PID Altitude hold Climb rate only Outer Z velocity PID Position hold 2D velocity, yaw rate Outer XY position PID Autonomous Waypoints / trajectory Trajectory planner"},{"location":"firmware-architecture/#53-rate-profiles","title":"5.3 Rate profiles","text":"<p>In Acro mode the stick is passed through a non-linear shaping curve before it becomes a rate setpoint. Four common profiles are implemented in this package (<code>betaflight_rate_profile</code>, <code>raceflight_rate_profile</code>, <code>actual_rate_profile</code>, <code>kiss_rate_profile</code>). They all share the same anatomy:</p> <pre><code>rate_sp = non_linear_curve(stick, rc_rate, expo, super_expo, limit)\n         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         converts normalised stick [-1,1] \u2192 body rate [rad/s]\n</code></pre> <p>A high <code>rc_rate</code> gives fast, nervous response. Adding <code>super_expo</code> provides a deadband near centre while still reaching the same maximum rate at full stick. See API Reference for details.</p>"},{"location":"firmware-architecture/#54-trajectory-planning-autonomous-mode","title":"5.4 Trajectory planning (autonomous mode)","text":"<p>For waypoint flight, PX4 runs a jerk-limited polynomial trajectory planner (<code>FlightTaskAutoMapper</code>) that generates smooth position/velocity/acceleration references at 50 Hz. Crazyflie uses a similar approach with the Crazyflie Commander stack and the optional <code>trajectorypy</code> high-level controller.</p>"},{"location":"firmware-architecture/#6-control-cascade","title":"6. Control Cascade","text":"<p>All modern quadcopter firmwares use a cascade (nested-loop) architecture. Each outer loop runs slower than its inner counterpart, and the output of one loop is the setpoint of the next.</p> <pre><code>Position  \u2192  Velocity  \u2192  Attitude  \u2192  Body Rate  \u2192  Motor Torque\n10\u201350 Hz      50\u2013100 Hz   100\u2013500 Hz    1\u20138 kHz        \u2014\n</code></pre>"},{"location":"firmware-architecture/#61-position-loop-1050-hz","title":"6.1 Position loop (10\u201350 Hz)","text":"<p>Input: position setpoint [m], measured position [m] Output: velocity setpoint [m/s]</p> <p>Simple proportional or PD controller. Integrator is usually omitted here and added in the velocity loop instead.</p> <pre><code>v_sp = kp_pos \u00d7 (p_sp - p) + kd_pos \u00d7 (\u1e57_sp - \u1e57)\n</code></pre> <p>In this package: <code>PosController_Vectorized.run_pos()</code>.</p>"},{"location":"firmware-architecture/#62-velocity-loop-50100-hz","title":"6.2 Velocity loop (50\u2013100 Hz)","text":"<p>Input: velocity setpoint [m/s], measured velocity [m/s] Output: desired linear acceleration [m/s\u00b2] (then decomposed into thrust + attitude)</p> <pre><code>a_des = kp_vel \u00d7 (v_sp - v) + ki_vel \u00d7 \u222b(v_sp - v) + mass \u00d7 g \u00d7 \u1e91   # world frame\n</code></pre> <p>The total desired force vector <code>F_des = mass \u00d7 a_des</code> is then decomposed:</p> <ul> <li>Thrust: <code>T = \u2016F_des\u2016</code> (scalar)</li> <li>Desired attitude: align body-z with <code>F_des / \u2016F_des\u2016</code></li> <li>Roll/pitch setpoint: <code>\u03c6_sp = arctan(-F_des,y / F_des,z)</code>, <code>\u03b8_sp = arctan(F_des,x / F_des,z)</code></li> </ul> <p>A horizontal angle limit is applied to prevent unreasonable commands: <code>\u03c6_sp, \u03b8_sp \u2208 [-30\u00b0, 30\u00b0]</code>.</p> <p>In this package: <code>PosController_Vectorized.run_vel()</code>.</p>"},{"location":"firmware-architecture/#63-attitude-angle-loop-100500-hz","title":"6.3 Attitude (angle) loop (100\u2013500 Hz)","text":"<p>Input: attitude setpoint (Euler RPY or quaternion), measured attitude Output: body-rate setpoint [rad/s]</p> <p>PID approach (Betaflight angle mode, Crazyflie):</p> <pre><code>\u03c9_sp = kp_att \u00d7 (q_sp \u2296 q_meas)   # error expressed in body frame\n</code></pre> <p>The quaternion error <code>q_sp \u2296 q_meas = q_meas\u207b\u00b9 \u2297 q_sp</code> is converted to a rotation vector (axis \u00d7 angle). Yaw is often handled separately to avoid coupling with roll/pitch.</p> <p>Geometric (SO(3)) approach (Lee controller, PX4 mc_att_control):</p> <p>The attitude error is computed on the Lie group directly:</p> <pre><code>e_R = \u00bd vee(R_des\u1d40 R - R\u1d40 R_des)\n\u03c9_sp = -kR \u00d7 e_R - k\u03a9 \u00d7 (\u03c9 - R\u1d40 R_des \u03c9_des)\n</code></pre> <p>This avoids singularities (gimbal lock) present in Euler-angle PID and has globally stable convergence proofs under mild conditions. See <code>LeePositionController</code> in this package.</p>"},{"location":"firmware-architecture/#64-rate-loop-500-hz-8-khz","title":"6.4 Rate loop (500 Hz \u2013 8 kHz)","text":"<p>The rate loop is the fastest and most critical control loop. It runs at the gyroscope sample rate (or half of it on constrained hardware).</p> <p>Input: body-rate setpoint [rad/s] from attitude loop, measured body rates [rad/s] Output: angular acceleration commands \u2192 body moments [N\u00b7m] \u2192 <code>(T, Mx, My, Mz)</code> wrench</p>"},{"location":"firmware-architecture/#classical-pid-betaflight-crazyflie","title":"Classical PID (Betaflight, Crazyflie)","text":"<pre><code>e = \u03c9_sp - \u03c9_meas\n\nP = kp \u00d7 e\nI += ki \u00d7 e \u00d7 dt                    # with anti-windup\nD = -kd \u00d7 (\u03c9_meas - \u03c9_meas_prev)/dt # D on measurement, not error (prevents derivative kick)\n\noutput = P + I + D\n</code></pre> <p>The derivative is applied to the measurement (not the error) to avoid impulse spikes when the setpoint steps. Betaflight further applies a dedicated D-term low-pass filter (cutoff 70\u2013150 Hz) separate from the gyro LPF.</p> <p>Feed-forward (Betaflight \u2265 3.5): add a term proportional to the rate setpoint derivative to reduce phase lag on sharp inputs:</p> <pre><code>FF = kff \u00d7 (\u03c9_sp - \u03c9_sp_prev) / dt\noutput += FF\n</code></pre>"},{"location":"firmware-architecture/#indi-incremental-nonlinear-dynamic-inversion","title":"INDI \u2014 Incremental Nonlinear Dynamic Inversion","text":"<p>Used in advanced firmwares (Paparazzi, some PX4 configurations, TU Delft research):</p> <p>The idea is to use the gyro acceleration (numerical derivative of \u03c9, filtered) as a direct measurement of the applied torque, and compute motor increments that produce the needed torque correction:</p> <pre><code>d\u03c9/dt_measured \u2248 (\u03c9[k] - \u03c9[k-1]) / dt\n\n\u0394u = G\u207b\u00b9 \u00d7 (d\u03c9/dt_desired - d\u03c9/dt_measured)\nu[k] = u[k-1] + \u0394u\n</code></pre> <p>where <code>G</code> is the control effectiveness matrix (relates motor speed increments to angular accelerations). INDI is inherently robust to model uncertainty because it operates on increments and relies on measurement rather than a plant model. Its main cost is sensitivity to gyro noise (requires aggressive differentiation).</p>"},{"location":"firmware-architecture/#7-control-allocation","title":"7. Control Allocation","text":"<p>Once the controller outputs a wrench <code>[T, Mx, My, Mz]</code>, the allocation step maps it to per-motor speed commands.</p>"},{"location":"firmware-architecture/#71-the-allocation-matrix","title":"7.1 The allocation matrix","text":"<p>For a quadrotor, each motor <code>i</code> at position <code>(xi, yi)</code> contributes:</p> <pre><code>T  = k_t \u00d7 \u03a3 \u03c9i\u00b2\nMx = k_t \u00d7 \u03a3 yi \u00d7 \u03c9i\u00b2          (roll)\nMy = k_t \u00d7 \u03a3 (-xi) \u00d7 \u03c9i\u00b2       (pitch)\nMz = k_d \u00d7 \u03a3 si \u00d7 \u03c9i\u00b2          (yaw, si = \u00b11 spin direction)\n</code></pre> <p>This gives a linear system <code>wrench = B \u00d7 \u03c9sq</code> where <code>\u03c9sq = [\u03c90\u00b2, ..., \u03c93\u00b2]</code>. The 4\u00d74 allocation matrix <code>B</code> is inverted once at startup:</p> <pre><code>\u03c9sq = B\u207b\u00b9 \u00d7 wrench\n\u03c9i  = \u221a(max(\u03c9sqi, \u03c9min\u00b2))\n</code></pre> <p><code>QuadMixer</code> in this package implements this exactly. The key parameters are the motor's thrust coefficient <code>k_t</code> (N\u00b7s\u00b2) and drag coefficient <code>k_d</code> (N\u00b7m\u00b7s\u00b2), which are identified experimentally (thrust stand measurement).</p>"},{"location":"firmware-architecture/#72-saturation-and-prioritisation","title":"7.2 Saturation and prioritisation","text":"<p>When the desired wrench cannot be achieved (e.g., maximum throttle while demanding a large roll), the allocation must choose what to sacrifice. Two common strategies:</p> <ol> <li>Simple clamping (Betaflight): clamp <code>\u03c9i</code> to <code>[\u03c9min, \u03c9max]</code> and accept the wrench error.</li> <li>Prioritised allocation (PX4, academic): iteratively scale down lower-priority axes (yaw first, then roll/pitch, then thrust) to remain within motor limits while satisfying higher-priority commands.</li> </ol>"},{"location":"firmware-architecture/#73-over-actuated-systems","title":"7.3 Over-actuated systems","text":"<p>Hex- and octorotors have more motors than DOF (6 or 8 vs 4). The pseudo-inverse <code>B\u2020 = B\u1d40(BB\u1d40)\u207b\u00b9</code> minimises the 2-norm of motor speeds for a given wrench. Some allocators additionally minimise power consumption (weighted pseudo-inverse) or distribute load evenly.</p>"},{"location":"firmware-architecture/#8-motor-and-esc-interface","title":"8. Motor and ESC Interface","text":""},{"location":"firmware-architecture/#81-protocol-evolution","title":"8.1 Protocol evolution","text":"Protocol Type Rate Latency Notes Standard PWM Analog, unidirectional 50\u2013400 Hz ~1 ms Original RC servo protocol OneShot125 Analog, faster 2 kHz ~500 \u00b5s Narrower pulse, same idea Multishot Analog 32 kHz ~30 \u00b5s Rarely used now DShot150/300/600 Digital, unidirectional 2\u20138 kHz ~50 \u00b5s Dominant standard since 2016 DShot1200 Digital 16 kHz ~25 \u00b5s High-speed, needs quality wiring Bidirectional DShot Digital, bidirectional 2\u20138 kHz ~50 \u00b5s ESC sends RPM eRPM back UAVCAN / DroneCAN CAN bus 1 kHz ~1 ms Robotics/autopilot use FDCAN CAN-FD 4 kHz ~250 \u00b5s Future high-bandwidth CAN <p>DShot encodes the motor command as a 16-bit word: 11 bits of throttle (0\u20132047), 1 telemetry request bit, and 4-bit CRC. The digital nature eliminates calibration and provides error detection.</p> <p>Bidirectional DShot (also called DShot EDT, extended telemetry) reuses the signal wire: after the FC transmits a DShot frame, it tristates the pin and the ESC transmits back the eRPM using inverted DShot encoding. This enables RPM-linked notch filters as described in Section 3.2.</p>"},{"location":"firmware-architecture/#82-esc-firmware","title":"8.2 ESC firmware","text":"<p>Modern ESCs run BLHeli_32, AM32, or BLHeli_S. They implement:</p> <ul> <li>FOC (Field-Oriented Control) or trapezoidal (6-step) commutation</li> <li>Active freewheeling: MOSFETs synchronously rectify during deceleration, recovering energy and reducing motor temperature</li> <li>Demag compensation: corrects back-EMF measurement errors at low RPM (startup)</li> <li>RPM governor (some firmwares): inner RPM loop that makes the motor's effective output proportional to throttle, linearising the <code>\u03c9 \u2192 T</code> relationship for the flight controller</li> </ul>"},{"location":"firmware-architecture/#83-motor-dynamics-and-latency-budget","title":"8.3 Motor dynamics and latency budget","text":"<p>The electrical time constant of a typical FPV brushless motor is \u03c4_e \u2248 0.1\u20131 ms. The mechanical time constant depends on the propeller inertia: typically \u03c4_m \u2248 20\u201380 ms for a 3\" racing quad, up to 150 ms for a 5\" with heavier props.</p> <p>Total latency budget (from gyro sample to motor output):</p> <pre><code>IMU read      :   ~0.1 ms\nGyro filter   :   ~0.3\u20132 ms  (depends on LPF cutoff)\nState estimate:   ~0.1 ms\nControl loops :   ~0.1 ms\nDShot frame   :   ~0.05 ms (DShot300 at 8 kHz)\nESC processing:   ~0.1 ms\nMotor step    :   20\u201380 ms (mechanical \u03c4)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal (non-mech): ~1\u20133 ms\n</code></pre> <p>The mechanical time constant dominates, which is why aerobatic quads use very stiff, light propellers.</p>"},{"location":"firmware-architecture/#9-failsafe-and-safety-systems","title":"9. Failsafe and Safety Systems","text":""},{"location":"firmware-architecture/#91-rc-link-loss","title":"9.1 RC link loss","text":"<p>When the FC detects missing RC frames (typically 100\u2013500 ms timeout), it enters failsafe:</p> <ol> <li>Stage 1 (drop): immediately drop throttle to zero (racing/FPV use)</li> <li>Stage 2 (return-to-home): execute a programmed RTH sequence (autonomous use)</li> </ol> <p>Betaflight implements \"Drop\", \"Land\", or \"GPS Rescue\" depending on the vehicle class and GPS availability.</p>"},{"location":"firmware-architecture/#92-sensor-health-monitoring","title":"9.2 Sensor health monitoring","text":"<ul> <li>IMU sanity check: if gyro reads &gt; \u00b14000 deg/s (physical limit), it flags a hardware fault</li> <li>EKF innovation check (PX4): large innovation (measurement residual vs prediction) in GPS or baro triggers sensor rejection</li> <li>Motor desync detection (BLHeli_32): if the ESC loses commutation timing, it re-arms the motor and reports a fault via DShot telemetry</li> <li>Voltage/current monitoring: Li-Po under-voltage triggers a landing or RTH</li> </ul>"},{"location":"firmware-architecture/#93-arming-logic","title":"9.3 Arming logic","text":"<p>Flight controllers require an explicit arming sequence before motors can spin:</p> <ol> <li>Throttle low (stick &lt; 1060 \u00b5s or normalised &lt; -0.88)</li> <li>Arm gesture (yaw right and hold 0.5 s, or dedicated arm switch)</li> <li>Pre-arm checks: GPS lock, EKF health, motor test, battery level</li> </ol> <p>This prevents accidental spin-up on the bench.</p>"},{"location":"firmware-architecture/#10-firmware-comparisons","title":"10. Firmware Comparisons","text":""},{"location":"firmware-architecture/#101-betaflight","title":"10.1 Betaflight","text":"<p>Target: FPV racing, freestyle, cinematic Language: C, heavily optimised for STM32 MCUs (F4/F7/H7) Control rate: 1\u20138 kHz rate loop (PID), RPM-linked notch + dynamic notch, bidirectional DShot</p> Feature Details Estimation Mahony complementary filter (attitude only) Outer loops Angle mode only; no onboard position hold without GPS module Mixer Static X/+ allocation, saturation via clamping Feed-forward Stick velocity \u2192 rate FF term INDI Not standard; experimental \"PIDSUM_LIMIT\" variant DShot DShot150\u20131200, bidirectional DShot EDT Configurator Betaflight Configurator (Chromium-based GUI) <p>Betaflight is the reference for latency-minimised attitude control. The 8 kHz loop (F7/H7 target) is rarely bottlenecked by computation.</p>"},{"location":"firmware-architecture/#102-px4","title":"10.2 PX4","text":"<p>Target: Autonomous UAVs, delivery drones, research Language: C++ on NuttX RTOS (Pixhawk) or Linux (companion computer) Control rate: 250\u2013500 Hz attitude, 50\u2013100 Hz position</p> Feature Details Estimation <code>ekf2</code>: full-state EKF (pos, vel, att, biases) fusing IMU + GPS + baro + mag + optflow + VIO Outer loops Full position/velocity cascade, trajectory planner, auto-takeoff/land, RTH Mixer Geometric + prioritised allocation via <code>ControlAllocator</code> module Rate controller PID with anti-windup + feed-forward INDI Supported as <code>mc_rate_control</code> option (<code>MC_AT_EN</code>) DShot DShot150\u2013600 via dedicated timer DMA driver Configurator QGroundControl, MAVLink protocol <p>PX4's key strength is its modular uORB publish-subscribe middleware: any module can subscribe to <code>vehicle_local_position</code>, <code>vehicle_attitude</code>, etc. without knowing the sensor source.</p>"},{"location":"firmware-architecture/#103-crazyflie-firmware","title":"10.3 Crazyflie firmware","text":"<p>Target: Research, indoor swarms, education Language: C on FreeRTOS (STM32F405) Control rate: 500 Hz PID (attitude + rate), 100 Hz position</p> Feature Details Estimation Mahony (attitude) + EKF (position, using UWB/LPS, optflow, or lighthouse) Outer loops Full cascade; position setpoints from CRTP over radio Mixer Direct PWM to motor driver (no DShot); software mixer Rate controller Cascade PID matching <code>pid_attitude.c</code> (matches this package's <code>CrazyfliePIDController</code>) INDI Not standard Protocols CRTP over 2.4 GHz radio (custom), USB, UART Configurator cfclient Python GUI, <code>cflib</code> Python API <p>Crazyflie's defining characteristic is its radio CRTP protocol and high-level commander stack, which allows a Python program running on a laptop to stream position setpoints at 100 Hz to a swarm of drones with minimal firmware-side changes.</p>"},{"location":"firmware-architecture/#11-connecting-to-this-package","title":"11. Connecting to This Package","text":"<p>The <code>drone_control</code> package implements the control cascade (Sections 6) and control allocation (Section 7) layers:</p> <pre><code>This package:\n  PosController_Vectorized   \u2192 position + velocity loops (\u00a76.1, \u00a76.2)\n  CrazyfliePIDController     \u2192 full cascade (\u00a76.1\u20136.4) matching Crazyflie firmware\n  LeePositionController      \u2192 geometric position + attitude control (\u00a76.3 SO(3) variant)\n  QuadMixer                  \u2192 control allocation (\u00a77.1)\n  betaflight_rate_profile    \u2192 RC reference generation (\u00a75.3)\n  tune_from_physics          \u2192 pole-placement gain tuning\n\nExternal (not in package):\n  Sensor acquisition         \u2192 hardware driver / ROS topic\n  IMU filtering              \u2192 e.g., scipy IIR in Python, or hardware firmware\n  State estimation           \u2192 Madgwick/Mahony/EKF (e.g., ahrs, pyekf, IsaacLab)\n  ESC communication          \u2192 DShot via UART or direct hardware\n</code></pre> <p>A typical simulation loop with this package:</p> <pre><code>from drone_control import load_config, LeePositionController, QuadMixer\n\ncfg    = load_config(\"configs/crazyflie.yaml\")\nctrl   = LeePositionController.from_drone_config(cfg, num_envs=N, device=\"cuda\")\nmixer  = QuadMixer.from_drone_config(cfg, device=\"cuda\")\n\n# Simulation step (called at ~500 Hz)\nthrust, moment = ctrl(root_state, pos_sp, vel_sp, acc_sp, yaw_sp, yaw_rate_sp)\nomega = mixer(thrust, moment)   # [N, 4] rad/s \u2192 send to sim motors\n</code></pre>"},{"location":"firmware-architecture/#12-further-reading","title":"12. Further Reading","text":"<ul> <li>T. Lee, M. Leok, N. H. McClamroch \u2014 Geometric tracking control of a quadrotor UAV on SE(3), CDC 2010</li> <li>F. Kendoul \u2014 Survey of advances in guidance, navigation and control of UAVs, JFR 2012</li> <li>S. Bouabdallah \u2014 Design and control of quadrotors with application to autonomous flying, EPFL 2007</li> <li>Betaflight wiki \u2014 rate profiles, RPM filter, DSHOT</li> <li>PX4 developer guide \u2014 EKF2, control allocator, INDI</li> <li>Crazyflie firmware \u2014 <code>src/modules/src/controller_pid.c</code>, <code>stabilizer.c</code></li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>git clone https://github.com/your-org/DroneStandalone\ncd DroneStandalone\npip install -e .\n</code></pre> <p>Dependencies: <code>torch &gt;= 2.0</code>, <code>pyyaml &gt;= 6.0</code>.</p> <p>To preview this documentation locally:</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic usage","text":""},{"location":"getting-started/#1-load-a-config","title":"1 \u2014 Load a config","text":"<pre><code>from drone_control import load_config\n\ncfg = load_config(\"configs/crazyflie.yaml\")\n\nprint(cfg.physics.mass)          # 0.027 kg\nprint(cfg.physics.max_thrust)    # 0.638 N\n</code></pre>"},{"location":"getting-started/#2-create-the-controller","title":"2 \u2014 Create the controller","text":"<pre><code>from drone_control import CrazyfliePIDController\n\nctrl = CrazyfliePIDController.from_drone_config(\n    cfg,\n    num_envs=4,    # parallel environments\n    dt=0.002,      # simulation timestep [s]  (= 500 Hz)\n    device=\"cpu\",\n)\n</code></pre>"},{"location":"getting-started/#3-build-the-root-state","title":"3 \u2014 Build the root state","text":"<p>The controller expects a <code>[N, 13]</code> tensor:</p> <pre><code>root_state = [ pos(3) | quat(4) | lin_vel(3) | ang_vel(3) ]\n</code></pre> <p>Quaternion convention: [w, x, y, z] (scalar first).</p> <pre><code>import torch\n\nN = 4\nroot_state = torch.zeros(N, 13)\nroot_state[:, 3] = 1.0      # identity quaternion (w = 1)\n</code></pre>"},{"location":"getting-started/#4-run-a-control-step","title":"4 \u2014 Run a control step","text":"<pre><code>target_pos = torch.tensor([[1.0, 0.0, 1.0]]).repeat(N, 1)\n\nthrust, moment = ctrl(\n    root_state,\n    target_pos=target_pos,\n    command_level=\"position\",\n)\n# thrust : [N, 1]  total thrust [N]\n# moment : [N, 3]  body moments [N\u00b7m]\n</code></pre>"},{"location":"getting-started/#command-levels","title":"Command levels","text":"Level Required inputs Description <code>\"position\"</code> <code>target_pos</code> Full cascade: pos \u2192 vel \u2192 att \u2192 rate <code>\"velocity\"</code> <code>target_vel</code> Enter at velocity loop <code>\"attitude\"</code> <code>target_attitude</code>, <code>thrust_cmd</code> Enter at attitude loop <code>\"body_rate\"</code> <code>target_body_rates</code>, <code>thrust_cmd</code> Inner rate loop only <p>All levels accept optional <code>target_yaw</code> or <code>target_yaw_rate</code>.</p>"},{"location":"getting-started/#resetting-environments","title":"Resetting environments","text":"<pre><code># Reset all environments (e.g. at episode start)\nctrl.reset()\n\n# Reset only environments 0 and 2 (e.g. after collision)\nctrl.reset(env_ids=torch.tensor([0, 2]))\n</code></pre>"},{"location":"getting-started/#per-environment-rate-gains","title":"Per-environment rate gains","text":"<p>Useful for domain randomisation:</p> <pre><code># Same gains for all envs\nctrl.set_rate_gains(rate_kp=torch.tensor([300., 300., 150.]))\n\n# Different gains for envs 0 and 1 only\nctrl.set_rate_gains(\n    rate_kp=torch.tensor([250., 250., 120.]),\n    env_ids=torch.tensor([0, 1]),\n)\n</code></pre>"},{"location":"getting-started/#motor-speeds-with-quadmixer","title":"Motor speeds with QuadMixer","text":"<p>After getting <code>thrust</code> and <code>moment</code> from any controller, convert them to per-motor speeds with <code>QuadMixer</code>:</p> <pre><code>from drone_control import QuadMixer\n\nmixer = QuadMixer.from_drone_config(cfg)   # requires drone.motor in YAML\n\nomega = mixer(thrust, moment)   # [N, 4]  rad/s\n# omega[:, 0] \u2192 M0 front-left (CCW)\n# omega[:, 1] \u2192 M1 front-right (CW)\n# omega[:, 2] \u2192 M2 back-right (CCW)\n# omega[:, 3] \u2192 M3 back-left (CW)\n</code></pre>"},{"location":"getting-started/#lee-geometric-controller","title":"Lee geometric controller","text":"<p>For singularity-free trajectory tracking use <code>LeePositionController</code>:</p> <pre><code>from drone_control import LeePositionController\n\nlee = LeePositionController.from_drone_config(cfg, num_envs=4)\n\nthrust, moment = lee(\n    root_state,\n    target_pos=torch.tensor([[0., 0., 1.]]).repeat(4, 1),\n)\n</code></pre> <p>The Lee controller is stateless \u2014 no <code>reset()</code> needed between episodes.</p>"},{"location":"getting-started/#rc-rate-profiles-acro-mode","title":"RC rate profiles (Acro mode)","text":"<p>Convert a normalised stick input [-1, 1] to a body-rate setpoint [rad/s]:</p> <pre><code>from drone_control import betaflight_rate_profile\n\nstick    = torch.zeros(4, 3)\nstick[:, 0] = 0.5             # 50 % roll stick\n\nomega_sp = betaflight_rate_profile(stick)   # [4, 3] rad/s\n\nthrust, moment = ctrl(\n    root_state,\n    target_body_rates=omega_sp,\n    thrust_cmd=torch.full((4, 1), 0.3),   # normalised throttle [N]\n    command_level=\"body_rate\",\n)\n</code></pre>"},{"location":"getting-started/#provided-configurations","title":"Provided configurations","text":"File Drone Mass Max thrust <code>configs/crazyflie.yaml</code> Crazyflie 2.1 27 g 0.638 N <code>configs/generic_quad_250mm.yaml</code> Generic 250 mm racing quad 250 g 12 N"},{"location":"tuning/","title":"Gain Tuning via Pole Placement","text":"<pre><code>from drone_control import tune_from_physics, TuningResult\n</code></pre>"},{"location":"tuning/#what-is-pole-placement","title":"What is pole placement?","text":"<p>A pole of a closed-loop system is a root of its characteristic polynomial. The pole's real part sets the settling speed; the imaginary part sets the oscillation frequency.  By choosing where to place the poles we pick the bandwidth \u03c9\u2080 and damping ratio \u03b6, and then solve for the PID gains algebraically.</p> <p>For a PI controller <code>C(s) = kp + ki/s</code> applied to the plant <code>G(s) = 1/s</code> (a pure integrator):</p> <pre><code>closed-loop char. poly  =  s\u00b2 + kp\u00b7s + ki\ndesired poly            =  s\u00b2 + 2\u03b6\u03c9\u2080\u00b7s + \u03c9\u2080\u00b2\n</code></pre> <p>Matching coefficients:</p> Gain Formula <code>kp</code> <code>2 \u00b7 \u03b6 \u00b7 \u03c9\u2080</code> <code>ki</code> <code>\u03c9\u2080\u00b2</code> <code>kd</code> <code>kp \u00b7 \u03c4_d</code> (optional derivative time)"},{"location":"tuning/#loop-hierarchy","title":"Loop hierarchy","text":"<p>The <code>CrazyfliePIDController</code> has four nested loops.  They must be tuned from the inside out and each outer loop must be at least 5\u00d7 slower than the loop it wraps, otherwise they interact and the system can become unstable.</p> <pre><code>rate  \u2192  att  \u2192  vel  \u2192  pos\n  \u03c9\u2080      \u03c9\u2080/5    \u03c9\u2080/25   \u03c9\u2080/125\n</code></pre> <p>If you only provide <code>bandwidth_rate</code>, the other three are derived automatically using this 5\u00d7 rule.</p>"},{"location":"tuning/#loop-summary","title":"Loop summary","text":"Loop Input error Output Plant <code>G(s)</code> Rate body rate [rad/s] angular accel [rad/s\u00b2] <code>1/s</code> Attitude angle [rad] rate setpoint [rad/s] <code>1/s</code> Velocity x/y horizontal vel [m/s] roll/pitch [deg] <code>g/s</code> Velocity z vertical vel [m/s] thrust delta [PWM] <code>K_z/s</code> Position position [m] vel setpoint [m/s] <code>1/s</code> (pure P) <p><code>K_z = max_thrust \u00b7 vel_thrust_scale / (thrust_cmd_max \u00b7 mass)</code> \u2014 converts PWM output to m/s\u00b2 acceleration.</p>"},{"location":"tuning/#tune_from_physics","title":"<code>tune_from_physics</code>","text":"<pre><code>result = tune_from_physics(\n    mass,\n    inertia,\n    bandwidth_rate,\n    bandwidth_att  = None,\n    bandwidth_vel  = None,\n    bandwidth_pos  = None,\n    damping        = 0.7,\n    derivative_time = 0.0,\n    max_thrust      = 0.638,\n    thrust_cmd_max  = 65535.0,\n    vel_thrust_scale = 1000.0,\n    sim_dt          = None,\n)\n</code></pre>"},{"location":"tuning/#parameters","title":"Parameters","text":"Parameter Type Description <code>mass</code> <code>float</code> Drone mass [kg] <code>inertia</code> <code>list[float]</code> <code>[Ixx, Iyy, Izz]</code> [kg\u00b7m\u00b2] <code>bandwidth_rate</code> <code>float</code> Rate loop bandwidth \u03c9\u2080 [rad/s].  Typical: 20\u201360 rad/s <code>bandwidth_att</code> <code>float \\| None</code> Attitude loop bandwidth [rad/s].  Default: <code>bandwidth_rate / 5</code> <code>bandwidth_vel</code> <code>float \\| None</code> Velocity loop bandwidth [rad/s].  Default: <code>bandwidth_att / 5</code> <code>bandwidth_pos</code> <code>float \\| None</code> Position loop bandwidth [rad/s].  Default: <code>bandwidth_vel / 5</code> <code>damping</code> <code>float</code> Damping ratio \u03b6.  0.7 \u2248 critical (\u22485 % overshoot), 1.0 = no overshoot <code>derivative_time</code> <code>float</code> \u03c4_d [s]: <code>kd = kp \u00b7 \u03c4_d</code>.  0 \u2192 pure PI <code>max_thrust</code> <code>float</code> Total max thrust [N] \u2014 used to scale z-velocity gains <code>thrust_cmd_max</code> <code>float</code> Full-scale PWM (default 65535) <code>vel_thrust_scale</code> <code>float</code> PWM scale in the firmware (default 1000) <code>sim_dt</code> <code>float \\| None</code> If given, emits warnings when a bandwidth exceeds 10 % of Nyquist"},{"location":"tuning/#returns","title":"Returns","text":"<p>A <code>TuningResult</code> dataclass.</p>"},{"location":"tuning/#tuningresult","title":"<code>TuningResult</code>","text":"<pre><code>@dataclass\nclass TuningResult:\n    bandwidth_rate: float\n    bandwidth_att:  float\n    bandwidth_vel:  float\n    bandwidth_pos:  float\n    damping:        float\n\n    rate_kp: list[float]   # [roll, pitch, yaw]\n    rate_ki: list[float]\n    rate_kd: list[float]\n\n    att_kp:  list[float]\n    att_ki:  list[float]\n    att_kd:  list[float]\n\n    vel_kp:  list[float]   # x/y in deg/(m/s), z in PWM/(m/s)\n    vel_ki:  list[float]\n    vel_kd:  list[float]\n\n    pos_kp:  list[float]\n    pos_ki:  list[float]\n    pos_kd:  list[float]\n\n    warnings: list[str]\n</code></pre>"},{"location":"tuning/#to_params-dict","title":"<code>.to_params() \u2192 dict</code>","text":"<p>Returns a dict compatible with <code>CrazyfliePIDController(params=...)</code>. Feed-forward terms and saturation limits keep their controller defaults.</p>"},{"location":"tuning/#summary-str","title":"<code>.summary() \u2192 str</code>","text":"<p>Prints a human-readable table of all gains, bandwidths, and any warnings.</p>"},{"location":"tuning/#example","title":"Example","text":"<pre><code>from drone_control import load_config, CrazyfliePIDController\nfrom drone_control import tune_from_physics\n\ncfg = load_config(\"configs/crazyflie.yaml\")\n\nresult = tune_from_physics(\n    mass=cfg.physics.mass,\n    inertia=[cfg.physics.inertia.ixx,\n             cfg.physics.inertia.iyy,\n             cfg.physics.inertia.izz],\n    bandwidth_rate=30.0,   # [rad/s]\n    damping=0.7,\n    max_thrust=cfg.physics.max_thrust,\n    sim_dt=0.002,\n)\nprint(result)\n</code></pre> <p>Output:</p> <pre><code>\u2500\u2500 Pole-placement tuning result \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Bandwidths  rate=30.0  att=6.0  vel=1.20  pos=0.240  rad/s\n  Damping \u03b6 = 0.7\n\n  Rate loop\n    kp = [42.0, 42.0, 42.0]\n    ki = [900.0, 900.0, 900.0]\n    kd = [0.0, 0.0, 0.0]\n\n  Attitude loop\n    kp = [8.4, 8.4, 8.4]\n    ki = [36.0, 36.0, 36.0]\n    kd = [0.0, 0.0, 0.0]\n\n  Velocity loop  (x/y in deg/(m/s), z in PWM/(m/s))\n    kp = [3.929, 3.929, 26.56]\n    ki = [3.347, 3.347, 22.63]\n    kd = [0.0, 0.0, 0.0]\n\n  Position loop\n    kp = [0.24, 0.24, 0.24]\n    ki = [0.0, 0.0, 0.0]\n    kd = [0.0, 0.0, 0.0]\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>Apply only the rate gains while keeping the rest at defaults:</p> <pre><code>ctrl = CrazyfliePIDController.from_drone_config(cfg, num_envs=1, dt=0.002)\nctrl.set_rate_gains(\n    rate_kp=result.to_params()[\"rate_kp\"],\n    rate_ki=result.to_params()[\"rate_ki\"],\n)\n</code></pre> <p>Or pass all gains at construction time:</p> <pre><code>ctrl = CrazyfliePIDController(\n    num_envs=1, dt=0.002,\n    mass=cfg.physics.mass,\n    inertia=[cfg.physics.inertia.ixx,\n             cfg.physics.inertia.iyy,\n             cfg.physics.inertia.izz],\n    params=result.to_params(),\n)\n</code></pre>"},{"location":"tuning/#choosing-the-bandwidth","title":"Choosing the bandwidth","text":"<code>bandwidth_rate</code> Effect &lt; 15 rad/s Sluggish; drones feel unresponsive 20\u201340 rad/s Good starting range for small quadrotors 40\u201360 rad/s Aggressive; requires low-noise sensors &gt; 60 rad/s Usually impossible without hardware-level filtering <p>Rule of thumb</p> <p>Start with <code>bandwidth_rate = 25.0</code> and <code>damping = 0.7</code>. Increase bandwidth until oscillation appears, then back off 20 %.</p> <p>Simulation timestep</p> <p>Pass <code>sim_dt</code> to get an automatic Nyquist sanity check. The rate bandwidth should stay below <code>0.1 / sim_dt</code> rad/s (e.g., \u2264 50 rad/s at dt = 2 ms).</p>"},{"location":"api/controller/","title":"CrazyfliePIDController","text":"<p>Cascaded PID controller modelled after the Crazyflie 2.x firmware.</p> <pre><code>from drone_control import load_config, CrazyfliePIDController\n\ncfg  = load_config(\"configs/crazyflie.yaml\")\nctrl = CrazyfliePIDController.from_drone_config(cfg, num_envs=4, dt=0.002)\n</code></pre>"},{"location":"api/controller/#constructor","title":"Constructor","text":"<pre><code>CrazyfliePIDController(\n    dt,\n    num_envs,\n    device=\"cpu\",\n    params=None,\n    mass=1.0,\n    inertia=None,\n)\n</code></pre> Parameter Type Description <code>dt</code> <code>float</code> Simulation timestep [s] <code>num_envs</code> <code>int</code> Number of parallel environments <code>device</code> <code>str</code> PyTorch device (<code>\"cpu\"</code>, <code>\"cuda\"</code>) <code>params</code> <code>dict</code> Override any gain or limit (see YAML format) <code>mass</code> <code>float</code> Drone mass [kg] <code>inertia</code> <code>list[float]</code> <code>[Ixx, Iyy, Izz]</code> principal moments [kg\u00b7m\u00b2]"},{"location":"api/controller/#class-method-from_drone_config","title":"Class method: <code>from_drone_config</code>","text":"<pre><code>ctrl = CrazyfliePIDController.from_drone_config(\n    drone_config,   # DroneConfig from load_config()\n    num_envs,\n    dt,\n    device=\"cpu\",\n)\n</code></pre> <p>Builds the controller from a loaded YAML config. If the config contains a <code>controllers.crazyflie_pid</code> section, those gains override the defaults. <code>thrust_cmd_scale</code> is derived automatically from <code>drone.max_thrust</code>.</p>"},{"location":"api/controller/#__call__-main-control-step","title":"<code>__call__</code> \u2014 main control step","text":"<pre><code>thrust, moment = ctrl(\n    root_state,\n    *,\n    command_level,\n    target_pos=None,\n    target_vel=None,\n    target_attitude=None,\n    target_body_rates=None,\n    target_yaw=None,\n    target_yaw_rate=None,\n    thrust_cmd=None,\n    body_rates_in_body_frame=False,\n)\n</code></pre>"},{"location":"api/controller/#root_state-n-13","title":"<code>root_state</code> \u2014 <code>[N, 13]</code>","text":"<pre><code>[ pos(3) | quat(4) | lin_vel(3) | ang_vel(3) ]\n</code></pre> <p>Quaternion: [w, x, y, z] (scalar first). Angular velocity is expected in the world frame by default; set <code>body_rates_in_body_frame=True</code> if it is already in the body frame.</p>"},{"location":"api/controller/#command_level","title":"<code>command_level</code>","text":"Value Required inputs Loop entry point <code>\"position\"</code> <code>target_pos [N, 3]</code> Full cascade <code>\"velocity\"</code> <code>target_vel [N, 3]</code> Velocity loop <code>\"attitude\"</code> <code>target_attitude [N, 3]</code>, <code>thrust_cmd [N, 1]</code> Attitude loop <code>\"body_rate\"</code> <code>target_body_rates [N, 3]</code>, <code>thrust_cmd [N, 1]</code> Rate loop only"},{"location":"api/controller/#yaw-inputs-all-command-levels","title":"Yaw inputs (all command levels)","text":"Input Shape Effect <code>target_yaw</code> <code>[N, 1]</code> Set absolute yaw setpoint [rad] <code>target_yaw_rate</code> <code>[N, 1]</code> Integrate yaw rate [rad/s] <p>If both are <code>None</code>, the yaw setpoint holds its previous value.</p>"},{"location":"api/controller/#returns","title":"Returns","text":"Output Shape Unit <code>thrust</code> <code>[N, 1]</code> Newtons [N] <code>moment</code> <code>[N, 3]</code> Newton-metres [N\u00b7m]"},{"location":"api/controller/#reset","title":"<code>reset</code>","text":"<pre><code>ctrl.reset()                                  # reset all envs\nctrl.reset(env_ids=torch.tensor([0, 2]))      # reset envs 0 and 2\n</code></pre> <p>Clears all integrators, derivative states, and internal setpoint buffers. <code>_step_count</code> is reset to 0 so decimation restarts.</p>"},{"location":"api/controller/#set_physical_params","title":"<code>set_physical_params</code>","text":"<pre><code>ctrl.set_physical_params(\n    mass=torch.tensor(0.027),\n    inertia_tensor=J,          # [N, 3, 3]\n)\n</code></pre> <p>Update mass and inertia at runtime (e.g. for domain randomisation).</p>"},{"location":"api/controller/#set_rate_gains","title":"<code>set_rate_gains</code>","text":"<pre><code>ctrl.set_rate_gains(\n    rate_kp=torch.tensor([250., 250., 120.]),\n    rate_ki=torch.tensor([500., 500.,  16.7]),\n    rate_kd=torch.tensor([  2.5,  2.5,   0.]),\n    env_ids=None,    # None \u2192 all envs; tensor \u2192 subset\n)\n</code></pre> <p>Update rate-loop gains per environment. The gains start as shared <code>[3]</code> tensors; calling this with <code>env_ids</code> promotes them to <code>[N, 3]</code>.</p>"},{"location":"api/controller/#internal-state-attributes","title":"Internal state attributes","text":"<p>These are exposed for testing and logging but should not be written directly.</p> Attribute Shape Description <code>_vel_sp</code> <code>[N, 3]</code> Current velocity setpoint [m/s] <code>_att_sp</code> <code>[N, 3]</code> Current attitude setpoint [rad] <code>_rate_sp</code> <code>[N, 3]</code> Current body-rate setpoint [rad/s] <code>_yaw_sp</code> <code>[N, 1]</code> Current yaw setpoint [rad] <code>_step_count</code> <code>int</code> Step counter used for decimation <code>pos_pid</code> <code>PID_Vectorized</code> Position loop PID <code>vel_pid</code> <code>PID_Vectorized</code> Velocity loop PID <code>att_pid</code> <code>PID_Vectorized</code> Attitude loop PID <code>rate_kp/ki/kd</code> <code>[3]</code> or <code>[N, 3]</code> Rate loop gains"},{"location":"api/controller/#decimation-properties","title":"Decimation properties","text":"Property Description <code>posvel_decimation</code> How many sim steps per pos/vel update <code>att_decimation</code> How many sim steps per att/rate update <code>posvel_dt</code> Effective dt for pos/vel PIDs [s] <code>att_dt</code> Effective dt for att/rate PIDs [s]"},{"location":"api/lee_controller/","title":"LeePositionController","text":"<p>Geometric position + attitude controller based on Lee et al., CDC 2010. Operates directly on SO(3) \u2014 no Euler-angle singularities.</p> <pre><code>from drone_control import load_config, LeePositionController\n\ncfg  = load_config(\"configs/crazyflie.yaml\")\nctrl = LeePositionController.from_drone_config(cfg, num_envs=4, device=\"cpu\")\n\nthrust, moment = ctrl(root_state, target_pos, target_vel, target_acc,\n                      target_yaw, target_yaw_rate)\n</code></pre>"},{"location":"api/lee_controller/#constructor","title":"Constructor","text":"<pre><code>LeePositionController(\n    mass,\n    inertia,          # [3] or [3, 3]\n    position_gain,    # [3]\n    velocity_gain,    # [3]\n    attitude_gain,    # [3]\n    angular_rate_gain,# [3]\n    num_envs=1,\n    max_acceleration=inf,\n    device=\"cpu\",\n)\n</code></pre> Parameter Type Unit Description <code>mass</code> <code>float</code> kg Drone mass <code>inertia</code> <code>list[float]</code> kg\u00b7m\u00b2 <code>[Ixx, Iyy, Izz]</code> (diagonal) or full <code>[3,3]</code> <code>position_gain</code> <code>list[float]</code> N/m <code>k_pos</code> \u2014 position error \u2192 force <code>velocity_gain</code> <code>list[float]</code> N\u00b7s/m <code>k_vel</code> \u2014 velocity error \u2192 force <code>attitude_gain</code> <code>list[float]</code> N\u00b7m/rad <code>k_R</code> \u2014 SO(3) attitude error \u2192 moment <code>angular_rate_gain</code> <code>list[float]</code> N\u00b7m\u00b7s/rad <code>k_\u03a9</code> \u2014 angular-rate error \u2192 moment <code>num_envs</code> <code>int</code> \u2014 Number of parallel environments <code>max_acceleration</code> <code>float</code> m/s\u00b2 Cap on the desired acceleration norm <code>device</code> <code>str</code> \u2014 PyTorch device"},{"location":"api/lee_controller/#class-method-from_drone_config","title":"Class method: <code>from_drone_config</code>","text":"<pre><code>ctrl = LeePositionController.from_drone_config(\n    drone_config,    # DroneConfig from load_config()\n    num_envs=1,\n    device=\"cpu\",\n)\n</code></pre> <p>Reads gains from the <code>controllers.lee</code> section of the YAML config. Requires that section to be present; raises <code>ValueError</code> otherwise.</p>"},{"location":"api/lee_controller/#__call__-main-control-step","title":"<code>__call__</code> \u2014 main control step","text":"<pre><code>thrust, moment = ctrl(\n    root_state,         # [N, 13]\n    target_pos,         # [N, 3]  or broadcastable\n    target_vel=None,    # [N, 3]  default zeros\n    target_acc=None,    # [N, 3]  default zeros  (feed-forward)\n    target_yaw=None,    # [N, 1]  default 0\n    target_yaw_rate=None, # [N, 1]  default 0\n    *,\n    body_rates_in_body_frame=False,\n)\n</code></pre>"},{"location":"api/lee_controller/#root_state-n-13","title":"<code>root_state</code> \u2014 <code>[N, 13]</code>","text":"<pre><code>[ pos(3) | quat(4) | lin_vel(3) | ang_vel(3) ]\n</code></pre> <p>Quaternion: [w, x, y, z] (scalar first).</p>"},{"location":"api/lee_controller/#returns","title":"Returns","text":"Output Shape Unit <code>thrust</code> <code>[N, 1]</code> Newtons [N] <code>moment</code> <code>[N, 3]</code> Newton-metres [N\u00b7m]"},{"location":"api/lee_controller/#control-law-summary","title":"Control law (summary)","text":"<p>Force (world frame):</p> <pre><code>F_des = \u2212k_pos\u00b7(p \u2212 p_des) \u2212 k_vel\u00b7(v \u2212 v_des) + mass\u00b7(g\u00b7\u1e91 + a_des)\n</code></pre> <p>Desired attitude: align body-z with <code>\u2212F_des / \u2016F_des\u2016</code>, then rotate around body-z to match <code>target_yaw</code>.</p> <p>Attitude error (on SO(3), avoids gimbal lock):</p> <pre><code>e_R = \u00bd \u00b7 vee( R_des\u1d40\u00b7R \u2212 R\u1d40\u00b7R_des )\n</code></pre> <p>Moment (body frame):</p> <pre><code>M = \u2212k_R\u00b7e_R \u2212 k_\u03a9\u00b7e_\u03a9 + \u03c9 \u00d7 (J\u00b7\u03c9)\n</code></pre> <p>where <code>e_\u03a9 = \u03c9 \u2212 R\u1d40\u00b7R_des\u00b7\u03c9_des</code> is the angular-rate error.</p>"},{"location":"api/lee_controller/#reset","title":"<code>reset</code>","text":"<pre><code>ctrl.reset(env_ids=None)\n</code></pre> <p>The Lee controller is stateless (no integrators). <code>reset()</code> is a no-op provided for API compatibility with <code>CrazyfliePIDController</code>.</p>"},{"location":"api/lee_controller/#stateless-vs-crazyfliepidcontroller","title":"Stateless vs CrazyfliePIDController","text":"Property <code>LeePositionController</code> <code>CrazyfliePIDController</code> Integrators None 4 \u00d7 PID integral states Attitude representation SO(3) quaternion Euler RPY Singularity-free Yes No (gimbal lock at \u00b190\u00b0 pitch) Requires reset on episode end No Yes Thrust/moment output Yes Yes Full cascade Yes (1 step) Yes (4 nested loops)"},{"location":"api/lee_controller/#example-with-quadmixer","title":"Example with <code>QuadMixer</code>","text":"<pre><code>from drone_control import load_config, LeePositionController, QuadMixer\nimport torch\n\ncfg   = load_config(\"configs/crazyflie.yaml\")\nctrl  = LeePositionController.from_drone_config(cfg, num_envs=N)\nmixer = QuadMixer.from_drone_config(cfg)\n\n# Simulation loop\nthrust, moment = ctrl(root_state, target_pos)\nomega = mixer(thrust, moment)   # [N, 4] motor speeds [rad/s]\n</code></pre>"},{"location":"api/loader/","title":"Configuration Loader","text":"<pre><code>from drone_control import load_config, DroneConfig\n</code></pre>"},{"location":"api/loader/#load_config","title":"<code>load_config</code>","text":"<pre><code>cfg = load_config(\"configs/crazyflie.yaml\")   # str or Path\n</code></pre> <p>Parses a drone YAML file and returns a <code>DroneConfig</code> dataclass. Raises <code>KeyError</code> if a required field is missing.</p>"},{"location":"api/loader/#droneconfig","title":"<code>DroneConfig</code>","text":"<pre><code>@dataclass\nclass DroneConfig:\n    physics:       DronePhysicsConfig\n    attitude:      AttitudeControllerConfig\n    position:      PositionControllerConfig\n    crazyflie_pid: dict | None              # raw params dict, or None\n    lee:           LeeControllerConfig | None\n</code></pre>"},{"location":"api/loader/#dronephysicsconfig","title":"<code>DronePhysicsConfig</code>","text":"Field Type Description <code>name</code> <code>str</code> Drone name <code>mass</code> <code>float</code> Mass [kg] <code>inertia.ixx/iyy/izz</code> <code>float</code> Principal moments of inertia [kg\u00b7m\u00b2] <code>max_thrust</code> <code>float</code> Total maximum thrust (all motors) [N] <code>motor</code> <code>MotorConfig \\| None</code> Motor/frame geometry (required for <code>QuadMixer</code>)"},{"location":"api/loader/#motorconfig","title":"<code>MotorConfig</code>","text":"<p>Populated from the <code>drone.motor</code> YAML section. Required by <code>QuadMixer</code>.</p> Field Type Unit Description <code>arm_length</code> <code>float</code> m Center-to-motor distance <code>k_thrust</code> <code>float</code> N\u00b7s\u00b2 Thrust coefficient: <code>F = k_thrust \u00b7 \u03c9\u00b2</code> <code>k_drag</code> <code>float</code> N\u00b7m\u00b7s\u00b2 Drag coefficient: <code>\u03c4 = k_drag \u00b7 \u03c9\u00b2</code> <code>layout</code> <code>str</code> \u2014 <code>\"x\"</code> or <code>\"+\"</code> quad layout <code>speed_min</code> <code>float</code> rad/s Minimum motor speed (clamped by mixer) <code>speed_max</code> <code>float</code> rad/s Maximum motor speed (clamped by mixer)"},{"location":"api/loader/#leecontrollerconfig","title":"<code>LeeControllerConfig</code>","text":"<p>Populated from the <code>controllers.lee</code> YAML section.</p> Field Type Unit Description <code>position_gain</code> <code>list[float]</code> N/m <code>k_pos</code> per axis <code>velocity_gain</code> <code>list[float]</code> N\u00b7s/m <code>k_vel</code> per axis <code>attitude_gain</code> <code>list[float]</code> N\u00b7m/rad <code>k_R</code> per axis <code>angular_rate_gain</code> <code>list[float]</code> N\u00b7m\u00b7s/rad <code>k_\u03a9</code> per axis <code>max_acceleration</code> <code>float</code> m/s\u00b2 Clip on desired acceleration norm (default <code>inf</code>)"},{"location":"api/loader/#attitudecontrollerconfig","title":"<code>AttitudeControllerConfig</code>","text":"Field Type Description <code>freq_rate_hz</code> <code>float</code> Inner (rate) loop frequency [Hz] <code>freq_angle_hz</code> <code>float</code> Outer (angle) loop frequency [Hz] <code>rate.{roll,pitch,yaw}</code> <code>PIDConfig</code> Rate loop PID per axis <code>angle.{roll,pitch,yaw}</code> <code>PIDConfig</code> Angle loop PID per axis"},{"location":"api/loader/#positioncontrollerconfig","title":"<code>PositionControllerConfig</code>","text":"Field Type Description <code>freq_vel_hz</code> <code>float</code> Inner (velocity) loop frequency [Hz] <code>freq_pos_hz</code> <code>float</code> Outer (position) loop frequency [Hz] <code>max_thrust_scale</code> <code>float</code> Safety factor on <code>max_thrust</code> (0\u20131) <code>max_horizontal_angle_deg</code> <code>float</code> Max roll/pitch from velocity controller [deg] <code>velocity.{vx,vy,vz}</code> <code>PIDConfig</code> Velocity loop PID per axis <code>position.{x,y,z}</code> <code>PIDConfig</code> Position loop PID per axis"},{"location":"api/loader/#pidconfig","title":"<code>PIDConfig</code>","text":"<pre><code>@dataclass\nclass PIDConfig:\n    kp:    float   # proportional gain\n    ki:    float   # integral gain\n    kd:    float   # derivative gain\n    tau:   float   # derivative low-pass time constant [s]\n    limit: float   # symmetric output saturation (\u00b1limit)\n</code></pre>"},{"location":"api/loader/#access-examples","title":"Access examples","text":"<pre><code>cfg = load_config(\"configs/crazyflie.yaml\")\n\n# Physics\nprint(cfg.physics.mass)               # 0.027\nprint(cfg.physics.inertia.ixx)        # 1.657e-5\nprint(cfg.physics.max_thrust)         # 0.638\n\n# Motor geometry (for QuadMixer)\nprint(cfg.physics.motor.arm_length)   # 0.046\nprint(cfg.physics.motor.k_thrust)     # 1.285e-8\n\n# Attitude rate gains (roll axis)\nprint(cfg.attitude.rate.roll.kp)      # 50.0\n\n# Position gains (z axis)\nprint(cfg.position.position.z.kp)     # 5.0\nprint(cfg.position.position.z.ki)     # 0.0\n\n# Raw CrazyfliePID params (dict)\nprint(cfg.crazyflie_pid[\"rate_kp\"])   # [250.0, 250.0, 120.0]\n\n# Lee geometric controller gains\nprint(cfg.lee.position_gain)          # [0.5, 0.5, 0.7]\nprint(cfg.lee.attitude_gain)          # [0.06, 0.06, 0.03]\n</code></pre>"},{"location":"api/mixer/","title":"QuadMixer","text":"<p>Maps a collective thrust + body moments wrench to per-motor angular speeds.</p> <pre><code>from drone_control import load_config, QuadMixer\n\ncfg   = load_config(\"configs/crazyflie.yaml\")\nmixer = QuadMixer.from_drone_config(cfg, device=\"cpu\")\n\nomega = mixer(thrust, moment)   # [N,1], [N,3] \u2192 [N,4] rad/s\n</code></pre>"},{"location":"api/mixer/#theory","title":"Theory","text":"<p>Each motor <code>i</code> produces:</p> <pre><code>F_i = k_thrust \u00b7 \u03c9i\u00b2     [N]          (thrust)\n\u03c4_i = k_drag   \u00b7 \u03c9i\u00b2     [N\u00b7m]        (reaction torque)\n</code></pre> <p>The total wrench on the body is assembled into a linear system:</p> <pre><code>wrench = B \u00b7 \u03c9sq\n</code></pre> <p>where <code>\u03c9sq = [\u03c90\u00b2, \u03c91\u00b2, \u03c92\u00b2, \u03c93\u00b2]</code> and B is the 4\u00d74 allocation matrix. Inverting B gives motor speeds from the desired wrench:</p> <pre><code>\u03c9sq = B\u207b\u00b9 \u00b7 wrench\n\u03c9i  = \u221a( clamp(\u03c9sqi, \u03c9min\u00b2, \u03c9max\u00b2) )\n</code></pre>"},{"location":"api/mixer/#frame-convention","title":"Frame convention","text":"<p>FLU body frame (Forward-Left-Up). Motor numbering (viewed from above):</p> <pre><code>X-config:\n   M0(CCW)  M1(CW)\n      \\      /\n       center\n      /      \\\n   M2(CCW)  M3(CW)\n\n  M0: front-left   (+d, +d)\n  M1: front-right  (+d, \u2212d)\n  M2: back-right   (\u2212d, \u2212d)\n  M3: back-left    (\u2212d, +d)\n  d = arm_length / \u221a2\n</code></pre> <p>Sign conventions:</p> <ul> <li><code>Mx &gt; 0</code> \u2192 left side rises (M0, M3 with y &gt; 0 push harder)</li> <li><code>My &gt; 0</code> \u2192 nose rises (M2, M3 with x &lt; 0 push harder)</li> <li><code>Mz &gt; 0</code> \u2192 yaw CCW</li> </ul>"},{"location":"api/mixer/#constructor","title":"Constructor","text":"<pre><code>QuadMixer(\n    arm_length,\n    k_thrust,\n    k_drag,\n    layout=\"x\",\n    speed_min=0.0,\n    speed_max=inf,\n    device=\"cpu\",\n)\n</code></pre> Parameter Type Unit Description <code>arm_length</code> <code>float</code> m Center-to-motor distance <code>k_thrust</code> <code>float</code> N\u00b7s\u00b2 Thrust coefficient: <code>F = k_thrust \u00b7 \u03c9\u00b2</code> <code>k_drag</code> <code>float</code> N\u00b7m\u00b7s\u00b2 Drag coefficient: <code>\u03c4 = k_drag \u00b7 \u03c9\u00b2</code> <code>layout</code> <code>str</code> \u2014 <code>\"x\"</code> (default) or <code>\"+\"</code> <code>speed_min</code> <code>float</code> rad/s Minimum motor speed (clamped) <code>speed_max</code> <code>float</code> rad/s Maximum motor speed (clamped) <code>device</code> <code>str</code> \u2014 PyTorch device"},{"location":"api/mixer/#class-method-from_drone_config","title":"Class method: <code>from_drone_config</code>","text":"<pre><code>mixer = QuadMixer.from_drone_config(\n    drone_config,   # DroneConfig from load_config()\n    device=\"cpu\",\n)\n</code></pre> <p>Reads all parameters from the <code>drone.motor</code> section of the YAML. Raises <code>ValueError</code> if that section is absent.</p>"},{"location":"api/mixer/#__call__","title":"<code>__call__</code>","text":"<pre><code>omega = mixer(thrust, moment)\n</code></pre> Argument Shape Unit <code>thrust</code> <code>[N, 1]</code> N <code>moment</code> <code>[N, 3]</code> N\u00b7m (Mx, My, Mz) Return Shape Unit <code>omega</code> <code>[N, 4]</code> rad/s <p>Motor order: M0, M1, M2, M3 (see frame convention above).</p>"},{"location":"api/mixer/#to","title":"<code>to</code>","text":"<pre><code>mixer = mixer.to(\"cuda\")\n</code></pre> <p>Moves internal tensors to a different device in-place. Returns <code>self</code>.</p>"},{"location":"api/mixer/#yaml-config-section","title":"YAML config section","text":"<pre><code>drone:\n  motor:\n    arm_length: 0.046      # m\n    k_thrust:   1.285e-8   # N\u00b7s\u00b2\n    k_drag:     7.645e-11  # N\u00b7m\u00b7s\u00b2\n    layout:     x          # 'x' or '+'\n    speed_min:  0.0        # rad/s\n    speed_max:  2618.0     # rad/s  (~25 000 RPM)\n</code></pre> <p>See YAML Config Format for the full schema.</p>"},{"location":"api/mixer/#full-pipeline-example","title":"Full pipeline example","text":"<pre><code>from drone_control import (\n    load_config, CrazyfliePIDController, QuadMixer\n)\nimport torch\n\ncfg   = load_config(\"configs/crazyflie.yaml\")\nctrl  = CrazyfliePIDController.from_drone_config(cfg, num_envs=4, dt=0.002)\nmixer = QuadMixer.from_drone_config(cfg)\n\n# Single control step\nroot_state = torch.zeros(4, 13); root_state[:, 3] = 1.0\ntarget_pos = torch.tensor([[0., 0., 1.]]).repeat(4, 1)\n\nthrust, moment = ctrl(root_state, target_pos=target_pos,\n                      command_level=\"position\")\nomega = mixer(thrust, moment)   # [4, 4] motor speeds in rad/s\n</code></pre>"},{"location":"api/pid/","title":"PID_Vectorized","text":"<p>Discrete-time PID controller, vectorized over N environments and optionally over multiple axes simultaneously.</p> <pre><code>from drone_control import PID_Vectorized\n</code></pre>"},{"location":"api/pid/#constructor","title":"Constructor","text":"<pre><code>PID_Vectorized(\n    num_envs=None,\n    device=\"cpu\",\n    *,\n    kp=1.0,\n    ki=0.0,\n    kd=0.0,\n    kff=0.0,\n    tau=0.01,\n    limit_up=inf,\n    limit_down=-inf,\n    integral_limit=None,\n)\n</code></pre> Parameter Type Description <code>num_envs</code> <code>int \\| None</code> Pre-allocate buffers for N envs. <code>None</code> \u2192 lazy init on first call <code>device</code> <code>str</code> PyTorch device <code>kp, ki, kd</code> <code>float \\| list \\| Tensor</code> PID gains \u2014 scalars for single-axis, <code>[axes]</code> for multi-axis <code>kff</code> <code>float \\| list \\| Tensor</code> Feed-forward gain <code>tau</code> <code>float</code> Derivative low-pass time constant [s]. <code>0</code> \u2192 raw backward difference <code>limit_up, limit_down</code> <code>float</code> Asymmetric output saturation bounds <code>integral_limit</code> <code>float \\| list \\| Tensor \\| None</code> Symmetric cap on the integral term before output anti-windup"},{"location":"api/pid/#single-axis-mode-num_envs-given","title":"Single-axis mode (<code>num_envs</code> given)","text":"<p>Each instance controls one axis across N environments. State shape: <code>[N]</code>. Used by <code>cascade.py</code>.</p> <pre><code>pid = PID_Vectorized(num_envs=4, device=\"cpu\",\n                     kp=6.0, ki=3.0, kd=0.0, tau=0.01,\n                     limit_up=15.708, limit_down=-15.708)\nout = pid(error, Ts=0.002)   # error: [4]  \u2192 out: [4]\n</code></pre>"},{"location":"api/pid/#multi-axis-mode-lazy-init","title":"Multi-axis mode (lazy init)","text":"<p>One instance handles all 3 axes. State shape: <code>[N, 3]</code>. Used by <code>CrazyfliePIDController</code>.</p> <pre><code>pid = PID_Vectorized(kp=[6., 6., 6.], ki=[3., 3., 1.], kd=0.,\n                     tau=0.0, device=\"cpu\",\n                     integral_limit=[0.349, 0.349, 6.283])\nout = pid(error, Ts=0.002)   # error: [N, 3]  \u2192 out: [N, 3]\n</code></pre>"},{"location":"api/pid/#forward-callable","title":"<code>forward</code> (callable)","text":"<pre><code>output = pid(error, Ts, feedforward=None, measurement_dot=None)\n</code></pre> Parameter Description <code>error</code> Tracking error, shape <code>[N]</code> or <code>[N, axes]</code> <code>Ts</code> Timestep [s] <code>feedforward</code> Optional signal; added as <code>kff * feedforward</code> <code>measurement_dot</code> Time derivative of the measurement (not the error). Enables derivative-on-measurement: <code>d_term = \u2212kd \u00b7 \u1e8b</code>"},{"location":"api/pid/#derivative-modes","title":"Derivative modes","text":"Condition Derivative computation <code>measurement_dot</code> provided <code>d = \u2212kd \u00b7 measurement_dot</code> (no setpoint kick) <code>tau &gt; 0</code> Tustin bilinear low-pass: <code>d = kd \u00b7 differentiator</code> <code>tau = 0</code> Raw backward difference: <code>d = kd \u00b7 (e \u2212 e_prev) / Ts</code>"},{"location":"api/pid/#anti-windup","title":"Anti-windup","text":"<p>Two-stage:</p> <ol> <li>Integral clamping (if <code>integral_limit</code> set): <code>ki\u00b7\u222be</code> is clamped and    the integral state is back-calculated to stay consistent.</li> <li>Output back-calculation: after output saturation, the integrator is    corrected by <code>(u_sat \u2212 u_unsat) / ki</code>.</li> </ol>"},{"location":"api/pid/#reset","title":"<code>reset</code>","text":"<pre><code>pid.reset()                                # reset all\npid.reset(env_ids=torch.tensor([0, 2]))   # reset subset\n</code></pre> <p>Zeroes: <code>integrator</code>, <code>differentiator</code>, <code>error_d1</code>, <code>u</code>, <code>u_unsat</code>.</p>"},{"location":"api/pid/#state-attributes","title":"State attributes","text":"Attribute Description <code>integrator</code> Integral accumulator <code>differentiator</code> Tustin-filtered derivative signal <code>error_d1</code> Previous error (for trapezoidal integration and backward diff) <code>u</code> Last saturated output <code>u_unsat</code> Last unsaturated output (before clamping)"},{"location":"api/rate_profiles/","title":"Rate Profiles","text":"<p>RC stick shaping functions that convert a normalised stick input to a body-rate setpoint.  Matches the firmware conventions of Betaflight, RaceFlight, Actual-rates, and KISS.</p> <pre><code>from drone_control import betaflight_rate_profile\n\nomega_sp = betaflight_rate_profile(stick)   # [N, 3] rad/s\n</code></pre>"},{"location":"api/rate_profiles/#overview","title":"Overview","text":"<p>In Acro/Rate mode the pilot controls body rates directly.  A raw stick signal is a normalised value in [\u22121, 1] where \u00b11 = full deflection. Rate profiles shape this signal with a non-linear curve before it becomes a rate setpoint, allowing:</p> <ul> <li>A soft centre (low sensitivity for precision hover)</li> <li>Expo / super-expo to keep a wide usable range in the mid-stick</li> <li>A hard limit at full stick</li> </ul> <p>All four functions share the same interface:</p> <pre><code>stick : [N, 3]   normalised  \u2208 [\u22121, 1]   (roll, pitch, yaw)\noutput: [N, 3]   rad/s\n</code></pre> <p>Output is always in rad/s (converted from the firmware's internal deg/s).</p>"},{"location":"api/rate_profiles/#betaflight_rate_profile","title":"<code>betaflight_rate_profile</code>","text":"<p>Betaflight triple-rate model with super-expo centre compression.</p> <pre><code>omega = betaflight_rate_profile(\n    stick,\n    rc_rate    = None,        # [3]  default [1.0, 1.0, 1.0]\n    super_expo = None,        # [3]  default [0.0, 0.0, 0.0]\n    expo       = None,        # [3]  default [0.0, 0.0, 0.0]\n    limit      = None,        # [3]  deg/s    default [670, 670, 670]\n)\n</code></pre> Parameter Shape Description <code>rc_rate</code> <code>[3]</code> Overall rate multiplier (0\u20133.0). 1.0 \u2248 200 \u00b0/s at full stick with defaults <code>super_expo</code> <code>[3]</code> Centre compression factor (0\u20130.99). Higher \u2192 more centre dead-zone <code>expo</code> <code>[3]</code> Expo factor (0\u20131.0). Softens centre without affecting full stick <code>limit</code> <code>[3]</code> Hard rate limit [deg/s] applied after shaping <p>The Betaflight formula:</p> <pre><code>rate_deg_s = 200 \u00b7 rc_rate \u00b7 stick\n           \u00b7 (1 + expo \u00b7 (stick\u00b2 \u2212 1))\n           / (1 \u2212 super_expo \u00b7 |stick|)\nrate_deg_s = clamp(rate_deg_s, \u2212limit, +limit)\n</code></pre>"},{"location":"api/rate_profiles/#raceflight_rate_profile","title":"<code>raceflight_rate_profile</code>","text":"<p>RaceFlight two-parameter model (rate + acro+).</p> <pre><code>omega = raceflight_rate_profile(\n    stick,\n    rate     = None,   # [3]  default [1.0, 1.0, 1.0]  \u2014 max rate [\u00b0/s \u00d7 100]\n    expo     = None,   # [3]  default [0.0, 0.0, 0.0]\n)\n</code></pre> <p>Simpler curve than Betaflight; commonly preferred for its more linear feel.</p>"},{"location":"api/rate_profiles/#actual_rate_profile","title":"<code>actual_rate_profile</code>","text":"<p>\"Actual Rates\" model \u2014 directly sets centre sensitivity and max rate.</p> <pre><code>omega = actual_rate_profile(\n    stick,\n    center_sensitivity = None,  # [3]  default [70.0, 70.0, 70.0]   deg/s per unit stick\n    max_rate           = None,  # [3]  default [670.0, 670.0, 670.0] deg/s at full stick\n    expo               = None,  # [3]  default [0.0, 0.0, 0.0]\n)\n</code></pre> <p>The most intuitive model because: - <code>center_sensitivity</code> directly sets the feel around centre - <code>max_rate</code> directly sets the angular rate at full stick</p>"},{"location":"api/rate_profiles/#kiss_rate_profile","title":"<code>kiss_rate_profile</code>","text":"<p>KISS firmware rate model (rate + expo).</p> <pre><code>omega = kiss_rate_profile(\n    stick,\n    rate = None,   # [3]  default [1.0, 1.0, 1.0]\n    expo = None,   # [3]  default [0.0, 0.0, 0.0]\n)\n</code></pre>"},{"location":"api/rate_profiles/#common-usage","title":"Common usage","text":"<pre><code>import torch\nfrom drone_control import betaflight_rate_profile\n\nN = 4\nstick = torch.zeros(N, 3)\nstick[:, 0] = 0.5    # 50 % roll stick\n\n# Default Betaflight curve\nomega_sp = betaflight_rate_profile(stick)    # [N, 3] rad/s\n\n# Custom high-rate setup\nomega_sp = betaflight_rate_profile(\n    stick,\n    rc_rate=torch.tensor([1.8, 1.8, 1.0]),\n    super_expo=torch.tensor([0.7, 0.7, 0.6]),\n    expo=torch.tensor([0.0, 0.0, 0.0]),\n    limit=torch.tensor([1200., 1200., 600.]),   # deg/s\n)\n</code></pre>"},{"location":"api/rate_profiles/#unit-note","title":"Unit note","text":"<p>All <code>limit</code> parameters are in deg/s (firmware convention). The functions convert their output to rad/s before returning.</p> <pre><code># Full stick, default params: output well below 200 rad/s (\u2248 3490 deg/s)\nomega = betaflight_rate_profile(torch.ones(1, 3))\nassert omega.abs().max() &lt; 200.0   # rad/s, not deg/s\n</code></pre>"},{"location":"api/rate_profiles/#connecting-to-a-rate-controller","title":"Connecting to a rate controller","text":"<p>Rate profile output feeds directly into the innermost loop of any controller that accepts <code>body_rate</code> commands:</p> <pre><code>from drone_control import CrazyfliePIDController, betaflight_rate_profile\n\nstick     = rc_input[..., :3]              # [N, 3]  normalised\nomega_sp  = betaflight_rate_profile(stick) # [N, 3]  rad/s\nthrust_cmd = rc_input[..., 3:4]            # [N, 1]  normalised throttle \u2192 PWM\n\nthrust, moment = ctrl(\n    root_state,\n    target_body_rates=omega_sp,\n    thrust_cmd=thrust_cmd,\n    command_level=\"body_rate\",\n)\n</code></pre>"},{"location":"config/yaml-format/","title":"YAML Config Format","text":"<p>A config file has these sections:</p> Section Required Used by <code>drone</code> Yes All controllers <code>drone.motor</code> No <code>QuadMixer</code> <code>controllers.attitude</code> Yes <code>AttitudeControllerConfig</code> <code>controllers.position</code> Yes <code>PositionControllerConfig</code> <code>controllers.crazyflie_pid</code> No <code>CrazyfliePIDController</code> <code>controllers.lee</code> No <code>LeePositionController</code>"},{"location":"config/yaml-format/#drone-physical-parameters","title":"<code>drone</code> \u2014 physical parameters","text":"<pre><code>drone:\n  name: \"Crazyflie 2.1\"\n  mass: 0.027            # [kg]\n  inertia:               # diagonal inertia tensor [kg\u00b7m\u00b2]\n    ixx: 1.657e-5\n    iyy: 1.657e-5\n    izz: 2.900e-5\n  max_thrust: 0.638      # total thrust of all motors [N]\n</code></pre>"},{"location":"config/yaml-format/#dronemotor-motor-and-frame-geometry","title":"<code>drone.motor</code> \u2014 motor and frame geometry","text":"<p>Required by <code>QuadMixer</code>. If absent, <code>cfg.physics.motor</code> is <code>None</code>.</p> <pre><code>drone:\n  motor:\n    arm_length: 0.046      # m    \u2014 center-to-motor distance\n    k_thrust:   1.285e-8   # N\u00b7s\u00b2 \u2014 F = k_thrust \u00b7 \u03c9\u00b2\n    k_drag:     7.645e-11  # N\u00b7m\u00b7s\u00b2 \u2014 \u03c4 = k_drag \u00b7 \u03c9\u00b2\n    layout:     x          # 'x' (default) or '+'\n    speed_min:  0.0        # rad/s\n    speed_max:  2618.0     # rad/s  (~25 000 RPM)\n</code></pre> <p><code>k_thrust</code> and <code>k_drag</code> are identified experimentally on a thrust stand. For the Crazyflie 2.1 these values come from F\u00f6rster (2015).</p>"},{"location":"config/yaml-format/#controllerscrazyflie_pid-crazyfliepidcontroller-gains","title":"<code>controllers.crazyflie_pid</code> \u2014 CrazyfliePIDController gains","text":"<p>This section is passed directly as the <code>params</code> dict to <code>CrazyfliePIDController</code>. All fields are optional; missing fields fall back to the built-in firmware defaults.</p>"},{"location":"config/yaml-format/#loop-rates","title":"Loop rates","text":"<pre><code>crazyflie_pid:\n  sim_rate_hz:             500.0   # expected call rate of the controller [Hz]\n  pid_posvel_loop_rate_hz: 100.0   # position + velocity loop rate [Hz]\n  pid_loop_rate_hz:        500.0   # attitude + rate loop rate [Hz]\n</code></pre> <p><code>posvel_decimation = round(sim_rate / posvel_rate)</code> \u2014 how many sim steps are skipped between pos/vel updates.</p>"},{"location":"config/yaml-format/#position-loop-error-m-velocity-setpoint-ms","title":"Position loop \u2014 <code>error [m] \u2192 velocity setpoint [m/s]</code>","text":"<pre><code>  pos_kp:  [2.0, 2.0, 2.0]\n  pos_ki:  [0.0, 0.0, 0.5]\n  pos_kd:  [0.0, 0.0, 0.0]\n  pos_kff: [0.0, 0.0, 0.0]\n</code></pre>"},{"location":"config/yaml-format/#velocity-loop-error-ms-rollpitch-cmd-deg-or-thrust","title":"Velocity loop \u2014 <code>error [m/s] \u2192 roll/pitch cmd [deg] or thrust \u0394</code>","text":"<pre><code>  vel_kp:  [25.0, 25.0, 25.0]\n  vel_ki:  [ 1.0,  1.0, 15.0]\n  vel_kd:  [ 0.0,  0.0,  0.0]\n  vel_kff: [ 0.0,  0.0,  0.0]\n</code></pre> <p>Unit convention for x/y</p> <p><code>vel_kp/ki/kd</code> for the x and y axes are in deg/(m/s) \u2014 the controller multiplies them by <code>DEG2RAD</code> internally so the numbers match the firmware's integer register values.</p>"},{"location":"config/yaml-format/#attitude-loop-error-rad-body-rate-setpoint-rads","title":"Attitude loop \u2014 <code>error [rad] \u2192 body-rate setpoint [rad/s]</code>","text":"<pre><code>  att_kp:  [6.0, 6.0, 6.0]\n  att_ki:  [3.0, 3.0, 1.0]\n  att_kd:  [0.0, 0.0, 0.35]\n  att_kff: [0.0, 0.0, 0.0]\n</code></pre>"},{"location":"config/yaml-format/#rate-loop-error-rads-angular-acceleration-rads2","title":"Rate loop \u2014 <code>error [rad/s] \u2192 angular acceleration [rad/s\u00b2]</code>","text":"<pre><code>  rate_kp:  [250.0, 250.0, 120.0]\n  rate_ki:  [500.0, 500.0,  16.7]\n  rate_kd:  [  2.5,   2.5,   0.0]\n  rate_kff: [  0.0,   0.0,   0.0]\n</code></pre> <p>Values match <code>platform_defaults_cf2.h</code> from the Crazyflie open-source firmware.</p>"},{"location":"config/yaml-format/#saturation-limits","title":"Saturation limits","text":"<pre><code>  att_integral_limit_deg:  [20.0, 20.0, 360.0]   # integral cap [deg]\n  rate_integral_limit_deg: [33.3, 33.3, 166.7]   # integral cap [deg/s]\n  pos_vel_max: [1.0, 1.0, 1.0]                   # velocity setpoint cap [m/s]\n  roll_max_deg:  20.0\n  pitch_max_deg: 20.0\n  yaw_max_delta: 0.0        # 0 = unlimited; &gt;0 clamps yaw change per step\n</code></pre>"},{"location":"config/yaml-format/#thrust-parameters","title":"Thrust parameters","text":"<pre><code>  thrust_base:      30000.0   # hover throttle estimate [PWM 0\u201365535]\n  thrust_min:       20000.0   # minimum throttle [PWM]\n  thrust_cmd_max:   65535.0   # full-scale throttle [PWM]\n  vel_thrust_scale: 1000.0    # (m/s\u00b2) \u2192 \u0394PWMconversion\n</code></pre> <p><code>thrust_cmd_scale</code> ([N/PWM]) is derived automatically from <code>drone.max_thrust / thrust_cmd_max</code> and does not need to be set manually.</p>"},{"location":"config/yaml-format/#controllerslee-leepositioncontroller-gains","title":"<code>controllers.lee</code> \u2014 LeePositionController gains","text":"<p>Optional. If absent, <code>cfg.lee</code> is <code>None</code>.</p> <pre><code>controllers:\n  lee:\n    position_gain:     [0.50, 0.50, 0.70]    # k_pos  [N/m]\n    velocity_gain:     [0.20, 0.20, 0.30]    # k_vel  [N\u00b7s/m]\n    attitude_gain:     [0.06, 0.06, 0.030]   # k_R    [N\u00b7m/rad]\n    angular_rate_gain: [0.002, 0.002, 0.001] # k_\u03a9    [N\u00b7m\u00b7s/rad]\n    # max_acceleration: inf                  # optional [m/s\u00b2]\n</code></pre> <p>Gains are in SI units. Values above are tuned for the Crazyflie 2.1 via pole placement at \u03c9_pos \u2248 4 rad/s, \u03c9_att \u2248 60 rad/s, \u03b6 = 0.7.</p>"},{"location":"config/yaml-format/#controllersattitude-attitudecontrollerconfig","title":"<code>controllers.attitude</code> \u2014 AttitudeControllerConfig","text":"<p>Used to populate <code>cfg.attitude</code> (available to all controllers via <code>DroneConfig</code>).</p> <pre><code>controllers:\n  attitude:\n    freq_rate_hz:  500\n    freq_angle_hz: 500\n    rate:\n      roll:  { kp: 50.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 50.265 }\n      pitch: { kp: 50.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 50.265 }\n      yaw:   { kp: 50.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 50.265 }\n    angle:\n      roll:  { kp: 4.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 15.708 }\n      pitch: { kp: 4.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 15.708 }\n      yaw:   { kp: 3.0, ki: 0.0, kd: 0.0, tau: 0.01, limit: 15.708 }\n</code></pre> <p><code>limit</code> is the symmetric output saturation bound (\u00b1limit). Units: rate loop [rad/s\u00b2], angle loop [rad/s].</p>"},{"location":"config/yaml-format/#controllersposition-positioncontrollerconfig","title":"<code>controllers.position</code> \u2014 PositionControllerConfig","text":"<pre><code>  position:\n    freq_vel_hz: 100\n    freq_pos_hz: 100\n    max_thrust_scale: 0.8            # effective max = 0.8 \u00d7 drone.max_thrust\n    max_horizontal_angle_deg: 30.0\n    velocity:\n      vx: { kp: 1.0, ki: 0.0, kd: 0.0, tau: 0.10, limit: 9999.0 }\n      vy: { kp: 1.0, ki: 0.0, kd: 0.0, tau: 0.10, limit: 9999.0 }\n      vz: { kp: 1.0, ki: 0.0, kd: 0.0, tau: 0.10, limit: 9999.0 }\n    position:\n      x: { kp: 5.0, ki: 0.0, kd: 1.0, tau: 0.10, limit: 10.0 }\n      y: { kp: 5.0, ki: 0.0, kd: 1.0, tau: 0.10, limit: 10.0 }\n      z: { kp: 5.0, ki: 0.0, kd: 3.5, tau: 0.10, limit:  5.0 }\n</code></pre>"},{"location":"config/yaml-format/#adding-a-new-drone","title":"Adding a new drone","text":"<ol> <li>Copy an existing config file:    <pre><code>cp configs/crazyflie.yaml configs/my_drone.yaml\n</code></pre></li> <li>Update the <code>drone</code> section (mass, inertia, max_thrust).</li> <li>Update <code>drone.motor</code> if you plan to use <code>QuadMixer</code> (measure <code>k_thrust</code>    and <code>k_drag</code> on a thrust stand, or use manufacturer data).</li> <li>Tune the <code>crazyflie_pid</code> gains using <code>tune_from_physics</code>    (see the tuning guide) or manually.</li> <li>Load it:    <pre><code>cfg   = load_config(\"configs/my_drone.yaml\")\nctrl  = CrazyfliePIDController.from_drone_config(cfg, num_envs=N, dt=dt)\nmixer = QuadMixer.from_drone_config(cfg)\n</code></pre></li> </ol>"}]}